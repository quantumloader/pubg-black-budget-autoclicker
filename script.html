// ---------------- GUI ----------------
if (document.getElementById("claimAutoPanel")) {
    document.getElementById("claimAutoPanel").remove();
}
const panel = document.createElement("div");
panel.id = "claimAutoPanel";
panel.style = `
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 2147483647;
    background: #0f1724;
    color: #e6eef8;
    padding: 12px 16px;
    border-radius: 10px;
    font-family: Inter, Roboto, Arial, sans-serif;
    font-size: 13px;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
`;
panel.innerHTML = `
  <div style="font-weight:600; margin-bottom:8px;">Claim Auto-Clicker (409-safe)</div>
  <div style="display:flex; gap:6px; margin-bottom:8px;">
    <button id="claimStartBtn" style="padding:6px 10px; border-radius:6px; cursor:pointer;">▶ Start</button>
    <button id="claimStopBtn"  style="padding:6px 10px; border-radius:6px; cursor:pointer;">⏹ Stop</button>
    <button id="claimResetBtn" style="padding:6px 10px; border-radius:6px; cursor:pointer;">↺ Reset</button>
  </div>
  <div id="claimStatus" style="opacity:0.9; font-size:12px;">Status: stopped</div>
  <div id="claimInfo" style="opacity:0.75; font-size:12px; margin-top:6px;">Info: waiting</div>
`;
document.body.appendChild(panel);

const statusEl = document.getElementById("claimStatus");
const infoEl = document.getElementById("claimInfo");
const startBtn = document.getElementById("claimStartBtn");
const stopBtn = document.getElementById("claimStopBtn");
const resetBtn = document.getElementById("claimResetBtn");

// ---------------- state ----------------
let running = false;
let loopTimer = null;
let waitingModal = false;
let conflictDetected = false; // флаг, ставится при 409 от drops
let lastConflictAt = null;

// ---------------- helper finders ----------------
function findClaimButton() {
    return Array.from(document.querySelectorAll("button, span, a"))
        .find(el => el.innerText?.trim() === "Claim Drops Rewards")
        ?.closest("button");
}
function findActivateButton() {
    return Array.from(document.querySelectorAll("button, span, a"))
        .find(el => el.innerText?.trim() === "Activate")
        ?.closest("button");
}
function findText(txt) {
    return Array.from(document.querySelectorAll("p, span, div"))
        .find(el => el.innerText?.includes(txt));
}
function findModal() {
    // учитываем ваши классы .modal .pbb-modal__container
    return document.querySelector(".modal, .pbb-modal__container");
}
function findOkButton() {
    return Array.from(document.querySelectorAll("button"))
        .find(btn => btn.innerText && btn.innerText.trim() === "OK");
}

// ---------------- wait utilities ----------------
function waitForElement(getter, interval = 100, timeout = 20000) {
    return new Promise((resolve, reject) => {
        const start = Date.now();
        const t = setInterval(() => {
            const el = getter();
            if (el) {
                clearInterval(t);
                resolve(el);
            } else if (Date.now() - start > timeout) {
                clearInterval(t);
                resolve(null);
            }
        }, interval);
    });
}
function waitForGone(getter, interval = 100, timeout = 20000) {
    return new Promise((resolve) => {
        const start = Date.now();
        const t = setInterval(() => {
            if (!getter()) {
                clearInterval(t);
                resolve(true);
            } else if (Date.now() - start > timeout) {
                clearInterval(t);
                resolve(false);
            }
        }, interval);
    });
}

// ---------------- network interception ----------------
// Перехватываем fetch
(function wrapFetch() {
    if (window.__claim_fetch_wrapped) return;
    window.__claim_fetch_wrapped = true;

    const origFetch = window.fetch;
    window.fetch = async function(input, init) {
        try {
            const response = await origFetch.apply(this, arguments);
            try {
                // проверяем URL и статус
                const url = (typeof input === "string") ? input : (input && input.url) || "";
                if (url && url.includes("/ec/v1/PBB/drops") && response && response.status === 409) {
                    conflictDetected = true;
                    lastConflictAt = Date.now();
                    infoEl.innerText = `Info: 409 received from ${url}`;
                    console.warn("[ClaimAuto] detected 409 from", url);
                }
            } catch (e) {
                console.warn("[ClaimAuto] fetch-check error", e);
            }
            return response;
        } catch (err) {
            throw err;
        }
    };
})();

// Перехватываем XMLHttpRequest
(function wrapXHR() {
    if (window.__claim_xhr_wrapped) return;
    window.__claim_xhr_wrapped = true;

    const OrigXML = window.XMLHttpRequest;
    function ProxyXHR() {
        const xhr = new OrigXML();
        const origOpen = xhr.open;
        xhr.open = function(method, url) {
            this.__claim_url = url;
            return origOpen.apply(this, arguments);
        };
        xhr.addEventListener("readystatechange", function() {
            try {
                if (this.readyState === 4) {
                    const url = this.__claim_url || "";
                    if (url.includes("/ec/v1/PBB/drops") && this.status === 409) {
                        conflictDetected = true;
                        lastConflictAt = Date.now();
                        infoEl.innerText = `Info: 409 received from ${url}`;
                        console.warn("[ClaimAuto] detected 409 XHR from", url);
                    }
                }
            } catch (e) { /* ignore */ }
        });
        return xhr;
    }
    window.XMLHttpRequest = ProxyXHR;
})();

// ---------------- modal handler ----------------
async function handleModalFlow() {
    // Ставим ожидание модалки/OK
    waitingModal = true;
    statusEl.innerText = "Status: handling modal (paused)";
    infoEl.innerText = "Info: waiting OK button...";
    // дождёмся появления OK (если вообще появится) — таймаут 15s
    const okBtn = await waitForElement(findOkButton, 100, 15000);
    if (okBtn) {
        try {
            infoEl.innerText = "Info: clicking OK...";
            okBtn.click();
        } catch (e) {
            console.warn("[ClaimAuto] click OK failed, trying dispatchEvent", e);
            try {
                okBtn.dispatchEvent(new MouseEvent("click", { bubbles: true, cancelable: true, view: window }));
            } catch (er) { /* ignore */ }
        }
    } else {
        infoEl.innerText = "Info: OK not found (timed out)";
    }
    // ждём пока модалка исчезнет (таймаут 10s)
    await waitForGone(findModal, 100, 10000);
    // После закрытия — очищаем флаг конфликта (даём небольшую буферную задержку)
    await new Promise(r => setTimeout(r, 150));
    conflictDetected = false;
    waitingModal = false;
    infoEl.innerText = "Info: modal closed, resuming";
    statusEl.innerText = "Status: running";
}

// ---------------- main claiming loop ----------------
async function claimLoop() {
    if (!running) return;
    // Проверка успеха
    if (findText("Congratulations") || findActivateButton()) {
        statusEl.innerText = "Status: SUCCESS!";
        infoEl.innerText = "Info: found Activate / Congratulations";
        running = false;
        return;
    }

    // Если обнаружен конфликт — ставим паузу и ждём модалку/OK
    if (conflictDetected) {
        statusEl.innerText = "Status: paused (409 detected)";
        // Начинаем обработку модалки, если ещё не начали
        if (!waitingModal) {
            handleModalFlow().catch(e => {
                console.warn("[ClaimAuto] handleModalFlow error", e);
                // попытка сброса флага чтобы не тормозить навсегда
                conflictDetected = false;
                waitingModal = false;
            });
        }
        loopTimer = setTimeout(claimLoop, 500);
        return;
    }

    // Если есть модалка (без явного 409) — подождём и обработаем так же
    if (findModal()) {
        statusEl.innerText = "Status: modal detected (no 409 flag), handling";
        if (!waitingModal) {
            handleModalFlow().catch(e => {
                console.warn("[ClaimAuto] handleModalFlow error", e);
                conflictDetected = false;
                waitingModal = false;
            });
        }
        loopTimer = setTimeout(claimLoop, 300);
        return;
    }

    // Нажимаем кнопку Claim (если есть)
    const claimBtn = findClaimButton();
    if (claimBtn) {
        statusEl.innerText = "Status: clicking Claim";
        infoEl.innerText = `Info: lastConflict: ${lastConflictAt ? new Date(lastConflictAt).toLocaleTimeString() : "never"}`;
        try {
            claimBtn.click();
        } catch (e) {
            // fallback: dispatch event
            try {
                claimBtn.dispatchEvent(new MouseEvent("click", { bubbles: true, cancelable: true, view: window }));
            } catch (er) {
                console.warn("[ClaimAuto] click claim failed", er);
            }
        }
    } else {
        statusEl.innerText = "Status: claim button not found";
        infoEl.innerText = "Info: waiting for Claim button";
    }

    // Небольшая задержка, затем следующий цикл
    loopTimer = setTimeout(claimLoop, 120);
}

// ---------------- GUI handlers ----------------
startBtn.onclick = () => {
    if (running) return;
    running = true;
    statusEl.innerText = "Status: running";
    infoEl.innerText = "Info: started";
    claimLoop();
};
stopBtn.onclick = () => {
    running = false;
    clearTimeout(loopTimer);
    statusEl.innerText = "Status: stopped";
    infoEl.innerText = "Info: stopped by user";
};
resetBtn.onclick = () => {
    conflictDetected = false;
    waitingModal = false;
    lastConflictAt = null;
    statusEl.innerText = "Status: reset";
    infoEl.innerText = "Info: flags cleared";
};

// ---------------- initial status ----------------
statusEl.innerText = "Status: stopped";
infoEl.innerText = "Info: ready (listening for 409)";

// ---------------- safety: clean up on page unload ----------------
window.addEventListener("beforeunload", () => {
    running = false;
    clearTimeout(loopTimer);
});
